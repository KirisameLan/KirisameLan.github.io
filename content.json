[{"title":"python爬虫 | 爬虫的概念及学习python爬虫所需的一些前端基础","path":"2022/02/08/学习python爬虫所需的一些前端基础/","text":"之前学过一点爬虫但却没有实际操作过，最近心血来潮决定一定要掌握基本的爬虫程序编写。第一篇就简单记录复制一下爬虫的相关概念和学习爬虫所需的前端基础。 爬虫的基本概念和工作原理网络爬虫的基本概念网络爬虫是一种根据特定爬取规则，自动抓取网页，提取网页内容，输出特定数据的应用程序。主要功能有: 广泛收集网页信息，形成 web 检索 根据兴趣需求，聚焦具体内容，面向主题进行数据采集 针对特定 web 应用系统或处理流程，实现自动化测试或模型检测 针对 web 系统可能存在的风险或漏洞，实现自动化安全测试和漏洞检测 网络爬虫的构成部分 需要爬取的网页地址 执行爬取策略的任务调度器 访问页面或下载数据的下载器 分析和提取页面内容的解析器 保存爬得数据结果的存储器 爬虫的基本工作原理 由用户给定一组网页 URLs，作为爬虫程序的输入，爬虫程序会将它们存放在待爬取队列中。 调度器 (Scheduler) 会从待爬取 URL 队列中逐一取出 URL，判断该 URL 是否已经被爬取过，即执行去重判断，之后，按照一定的遍历策略或负载策略，对 URL 发起网络爬取任务，也就是执行相应的 HTTP 请求。 下载器将逐一执行调度器产生的每个 HTTP 请求, 下载对应的 Web 内容，返回结果包括:HTML 网页、CSS 文件、JavaScript、图片等等。 解析器对下载器获得的 HTML 页面内容进行解析，提取出用户关心的部分内容，这其中，既包括用户感兴趣的关键数据; 也包括有待下一步爬取的新的 URLs。 存储器负责按照一定的存储模式，将解析器提取得到的用户兴趣数据存储到文件或数据库中，以供后续数据分析和处理使用。 解析器提取的需要进一步爬取的新 URLs，会被送往待爬取 URLs 队列。 网络爬虫的功能需求 像浏览器一样，能够向网站服务器发出请求，获得 web 网页。 能够将 web 网页中有关主题的信息进行定位，然后提取出来。 能够将提取出的信息进行组织，有序存储到文件或数据库中。 能够发现新的与主题相关的网页，自动完成进一步的主题爬取。 爬虫相关web技术介绍相关web技术概述Web 是一种基于 HTML 和 HTTP 的全球性的分布式图形信息系统， 它是建立在 internet 上的一种网络服务。构成 web 的五大要素有： web 页面的统一资源定位符 (URL) 超文本传输协议 (HTTP) 超文本标记语言 (HTML) Web 服务器 Web 浏览器 网络爬取的入口URL URL (Uniform Resource Locator) 意为统—资源定位符，具有唯一性和通用性。 唯一性：互联网上的每个文件都有一个唯一的 URL 通用性：URL 的构成遵循一定格式 URL 的格式分为 7 个部分: 访问模式 (或称通信协议)、用户信息、主机名称 (或 IP 地址)、访问端口、路径、查询、片段 URL=scheme:[//authority]path[?query][#fragment] 访问模式 (或称通信协议) ：指示服务器采用哪种协议或应用服务，来接收来自客户端的请求，并给予响应。例如 http、ftp 等。 用户信息 ：非必填，用户信息通常表现为用户名：用户密码，后加 @ 作为间隔符。 主机名称 (或 IP 地址) ：即 web 网页所在服务器的域名或是 IP 地址。 访问端口 ：非必填，服务器上某个正在运行的网络服务程序的访问地址。以整数形式标识，范围是 0~65535。 路径 ：路径由 1 个或多个“/”符号隔开的字符串组成，一般用来表示主机上的一个 web 访问目录或具体的文件路径。 查询 ：查询常用于向网站服务器传递参数，查询通常由? 开始，查询参数使用参数名 = 参数值的格式，有多个参数时，中间用 &amp;(and) 符号隔开。 片段 ：通常以一个 # 号开启，用于辅助定位。 网页下载的原理超文本传输协议超文本传输协议是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。 HTTP的工作原理：HTTP由请求和响应构成，采用客户端-服务器模式工作。客户端也即浏览器或网络爬虫程序，发出HTTP请求，而服务器对请求进行响应。 具体的工作过程： 用户输入URL，客户端程序在完成域名解析后，获得服务器IP地址; 通过服务器上操作系统提供的TCP/IP协议栈程序，与服务器建立TCP连接，与服务器建立TCP连接(TCP的三次握手); TCP连接建立后,客户端程序将HTTP请求封装为HTTP数据包，再封装为TCP数据包，发往服务器; 服务器接收HTTP请求后，根据请求内容进行响应,响应数据也封装为HTTP数据包，然后再封装为TCP包，回复给客户端。 服务器关闭这次TCP连接。等待新的请求。 三点注意事项： HTTP是无连接 无连接:限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。 HTTP是媒体独立的：客户端以及服务器指定使用适合的多用途互联网邮件扩展类型(MIME-type内容类型)。 HTTP是无状态 无状态是指协议对于事务处理没有记忆能力。 HTTP请求与响应HTTP请求方法HTTP1.0定义三种请求方法 GET方法：用于请求指定的页面信息,并返回实体主体。是最为常见的HTTP请求方法。 POST方法：向指定资源提交数据进行处理请求。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 HEAD方法：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。 HTTP1.1新增五种请求方法 PUT方法：从客户端向服务器传送数据，取代指定文档的内容，类似于更新操作。 DELETE方法：用于请求服务器删除URL指定的资源。 OPTIONS方法：用于客户端查看服务器性能参数。 TRACE方法：用于回显服务器收到的请求，主要用于测试或诊断。 CONNECT方法：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 请求头部的参数内容 Accept参数：用于向服务器申明客户端(浏览器)可以接受的媒体类型(MIME)的资源常见赋值：text/html、application/xhtm+xml、application/xml类型表示客户端允许接收文本、HTML文件、XML文件等，可使用通配符*/*。 Accept-encoding参数：参数的作用事项服务器声明客户端(浏览器)允许接收的压缩编码算法。常见赋值：gzip,deflate或br等等。 Accept-Language参数：用于向服务器申明客户端允许接收的语言。常见赋值：en-US, en和zh-CN等。q，取值范围是从0到1，q表示了权重，en-US的权重最高，为1,中文网站通常会将zh的权重q设为0.9。 Cache-control参数：用于控制客户端的缓存。常见赋值：private、no-cache、max-age、must-revalidate默认为private，意思是由浏览器自身决定缓存大小。 Connection参数：用于设置浏览器是否需要与服务器持久连接。常见取值：keep-alive和no;keep-alive表示需要持久连接,而no表示完成此次访问后即关闭连接。 Cookie参数：网站服务器为了辨别用户身份、进行会话跟踪而储存在用户本地终端上的数据(通常经过加密)。在HTTP请求头中设置这个参数，在向服务器发送请求时，就会将保存在该参数下的cookie值发送给web服务器，服务器根据这些值可以获得用户信息和访问历史。 Host参数：用于指定请求发往的服务器的域名和端口号。 Upgrade-insecure-Requests参数：被赋值为1时，用于声明浏览器支持从http请求自动升级为https请求，并且在以后发送请求的时候都使用https;设置为0时则不允许升级为HTTPs。 User-Agent参数：用于向服务器发送浏览器的版本、系统、应用程序的信息。常见赋值：Mozilla/5.0 (Windows NT 10.0; WOW64)、AppleWebKit/537.36(KHTML, like Gecko)、Chrome/72.0.3626.121、Safari/537.36 Refer参数：用于告诉服务器，客户端是通过哪个页面跟踪到当前页面的。即客户端访问的上一页面地址。 HTTP响应HTTP响应结构 状态行 响应头部（消息报头） 空行 响应正文（消息体） HTTP响应状态码HTTP响应状态码也称为HTTP Status Code，它指示了当前网络访问的状态。HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。 HTTP状态码共分为5种类型： 从100到199：响应类型为“信息”，即服务器收到请求,提示客户端继续执行某项操作; 从200到299：响应类型为成功，表示客户端请求被服务器成功接收并处理; 从300到399：响应类型为重定向,表示客户端请求需要进一步的操作以完成请求; 从400到499：响应类型为客户端错误，表示请求包含语法错误或无法完成请求; 从500到599：响应类型为服务器错误，表示服务器在处理请求的过程中发生了错误。 一些常见的HTTP响应码: 状态码 含义 100 继续。客户端应继续其请求。 101 切换协议。服务器根据客户端的请求切换协议。 200 请求成功。一般用于GET与POST请求的响应。 201 已创建。请求成功并创建了新的资源。 202 已接受。即服务器已经接受请求，但未处理完成。 301 永久移动。请求的资源已被永久的移动到新URL，返回信息会包括新的URL，浏览器会自动定向到新URL。今后任何新的请求都应使用新的URL代替。 302 临时移动。与301类似。客户端应继续使用原有URL。 400 客户端请求的语法错误，服务器无法理解。 401 请求要求用户的身份认证。 403 服务器理解请求客户端的请求,但是拒绝执行此请求。 404 服务器无法根据客户端的请求找到资源(网页)。 500 服务器内部错误，无法完成请求。 501 服务器不支持请求的功能,无法完成请求。 502 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。 响应头部的参数内容 Access-Control-Allow-Origin参数：用于指定哪些网站可以跨域源资源共享。 常见取值：*，表示允许所有网站跨域共享。 Accept-Patch参数：用于指定服务器所支持的文档补丁格式。 例如取值：text/example;charset=utf-8表示支持文本，编码格式为utf-8。 Accept-Ranges参数：表示服务器所支持的内容范围。 常见取值为bytes。 Age参数：表示响应对象在代理缓存中存在的时间，以秒为单位。 Allow参数：用于指定对于特定资源的有效动作。常见取值：GET, HEAD等方法。 Cache-Control参数：用于通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒。 例设置值为max-age=3600，表示缓存有效时间为1小时。 Content-Disposition参数：表示对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作。 Content-Encoding参数：表示响应资源所使用的编码类型。常见取值为gzip等。 Last-Modified参数：表示所请求的对象的最后修改日期。 Set-cookie参数：用于设置HTTP cookie值。 Date参数：用于指明响应发送时的日期和时间。 Expires参数：用于指定一个日期/时间，超过该时间则认为此响应已经过期。 Server参数：用于指明服务器名称。 Transfer-Encoding参数：用于表示实体传输给用户的编码形式。 内容解析的对象HTML由**超文本标记语言(Hyper text markuplanguage，简称HTML)**组织的web网页是爬虫程序进行内容解析的主要对象。 HTML它是用来描述网页的一种语言。HTML不是一种编程语言,而是一种标记语言，HTML使用一套标记标签(markup tag)来描述网页中的组成内容。HTML标签标记的内容，连同标签本身，被称为HTML元素。 &lt;!DOCTYPE html&gt;声明为HTML5文档; &lt;html&gt;标签是HTML页面的根标签; 每一个HTML文档的最外层都是&lt;html&gt;标签对。 &lt;head&gt;标签用于定义HTML文档的头部，是所有头部元素的容器。HTML头部常含有&lt;title&gt;标签，用于定义文档的标题。 &lt;base&gt;标签，它为页面上的所有链接规定的默认地址或默认目标。&lt;link&gt;标签，用于定义文档与外部资源之间的关系。 &lt;link&gt;最常用于连接样式表。&lt;style&gt;标签用于为HTML文档定义样式信息。 &lt;meta&gt;标签 meta元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。&lt;body&gt;元素定义了可见的页面内容。&lt;h1&gt;-&lt;h6&gt;等标签用于定义HTML中从1级到6级的标题。这类标签标记的内容，会以粗体或大号字体形式显示。 &lt;p&gt;标签，用于定义HTML文档中的段落。&lt;a&gt;标签用于定义URL链接。URL链接通过标签中的属性给出。属性总以名称、值、对的形式出现，并总在HTML元素的开始标签中规定。每个html都可以设置属性，&lt;a&gt;标签中常见的属性是href。 &lt;img&gt;标签用来定义图像，标签img中，可以设置属性src，用于指定图片的路径位置; &lt;table&gt;标签用来定义表格。每个表格均有若干行，行由&lt;tr&gt;标签定义,，每行被分割为若干单元格，单元格由&lt;td&gt;标签定义。字母td指表格数据(table data)，即数据单元格的内容。数据单元格包含:文本、图片、列表、段落、表单、水平线、表格…无序列表由&lt;ul&gt;标签指定,有序列表由&lt;ol&gt;标签指定,列表中的每个列表项使用&lt;li&gt;来指定。 &lt;div&gt;标签是可用于组合其他 HTML元素的容器，本身没有特定的含义。常与CSS一同使用，对大的内容块设置样式属性。&lt;span&gt;标签可用作文本的容器，本身没有特定的含义。当与CSS一同使用时,&lt;span&gt;元素可用于为部分文本设置样式属性。 &lt;form&gt;标签用于定义HTML表单，表单用于搜集不同类型的用户输入。表单元素是指不同类型的input元素、复选框、单选按钮、提交按钮…&lt;script&gt;标签用于定义客户端脚本，比如JavaScript。script元素既可包含脚本语句，也可通过src属性指向外部脚本文件。JavaScript最常用于图片操作、表单验证以及内容动态更新。JAVASCRIPT脚本可以增强显示效果、加载数据。 HTML的样式包括外部样式表、内部样式表、内联样式。样式表，全称是层叠样式表(Cascading Stylesheets)，简称CSS。单独组织样式，是为了解决内容与表现分离的问题。HTML文档本身组织内容，CSS样式表定义如何显示。这样可以极大提高工作效率。HTML文档、CSS样式表、JavaScript脚本是网页中最常见的资源。 存储数据的仓库存储数据的方式： 以文本文件形式存储 以数据库形式存储 文本文件存储数据 格式 描述 纯文本文件 缺少格式控制，也被称为无结构文本，机器可读性较差 csv 全称是逗号分隔值文件，因为分隔字符通常是逗号。当分割符不是逗号时，可以称其为字符分隔值文件。 XML 被设计用来在互联网上传输和存储数据。 Json 是另一种文本文件。它使用JavaScript对象表示法来组织数据。 YAML 是另外一种文本文件。YAML是YAML Ain’t a Markup Language的外文缩写。YAML的开发者认为YAML是一种对人类友好可读的，面向所有编程语言的数据序列化标准。 数据库管理系统关系型数据库关系型数据库是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。 关系型数据库支持事务的ACID原则。 ACID原则：Atomic原子性、Consistency一致性、Isolation隔离性、Durability持久性 关系型数据库具有容易理解、使用方便、易于维护的优点。但由于关系数据表存放在硬盘上，当访问量非常大时，磁盘I/O是性能瓶颈，关系数据库的大表查询效率、多表关联查询，复杂SQL查询的效率较低，它的扩展性较差，不能简单通过添加更多的硬件和服务节点来扩展性能和负载能力。 非关系型数据库非关系型数据库指非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统。 易于扩展、适应大数据量查询，性能较高，具有灵活的数据模型，用户可以随时自定义数据格式，在不影响性能的情况下，可以方便地实现高可用架构。 没有标准，没有存储过程，不支持SQL语句，NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。 常见的NoSQL产品有三类: 类型 描述 典型代表 键值存储数据库 主要会使用到哈希表，在这个表中有一个特定的键和一个指针指向特定的数据。 TokyoCabinet/Tyrant、Redis、Voldemort、OracleBDB 列存储数据库 这部分数据库通常是用来应对分布式存储的海量数据。 cassandra、HBASE、Rlak 文档型数据库 灵感来自于Lotus Notes办公软件，它同第一种键值存储相类似。 CouchDB、MongoDB、SequoiaDB 图形(Graph)数据库 图形结构的数据库同其它行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。 Neo4J、InfoGrid、InfiniteGraph"},{"title":"日语数量词的音变规则总结","path":"2021/11/19/日语数量词的音变规则总结/","text":"在学习日语的初级阶段我遇到的第一个困难便是日语众多的助数词了，各种各样与汉语不尽相同的量词及其音变着实让人头疼。 特撰写此文总结一下日语数量词的音变规则及声调变化。 开始要说音变规律，我们可以先从音变的种类说起。日语中的音变可以分为三类：促音变、浊音变和半浊音变。 这篇先咕一会。"},{"title":"Hadoop | Hadoop初体验——实现两个excel表格的自然连接","path":"2021/11/16/Hadoop初体验/","text":"一次Hadoop Mapreduce作业的完成过程 应该是第一次正儿八经地接触与大数据相关的东西，好多名词都看不明白。 记录一下我完成这次作业时的思考。 先放代码 题目： 在关系代数中，自然连接(Natural join)是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。 根据给定的数据《student.xlsx》和《student_course.xlsx》，请使用MapReduce计算模型，实现表student和表student_course的自然连接，结果集包括学生学号、姓名、选修课程编号、考试成绩。 什么是Hadoop？Hadoop是一个能够对大量数据进行分布式处理的软件框架。 Hadoop框架透明地为应用提供可靠性和数据移动。它实现了名为MapReduce的编程范型：应用程序被分割成许多小部分，而每个部分都能在集群中的任意节点上执行或重新执行。此外，Hadoop还提供了分布式文件系统，用以存储所有计算节点的数据，这为整个集群带来了非常高的带宽。MapReduce和分布式文件系统的设计，使得整个框架能够自动处理节点故障。它使应用程序与成千上万的独立计算的电脑和PB级的数据连接起来。现在普遍认为整个Apache Hadoop“平台”包括Hadoop内核、MapReduce、Hadoop分布式文件系统（HDFS）以及一些相关项目，有Apache Hive和Apache HBase等等。 那分布式又是什么呢？（ 简单来说就是就是将一个需要巨大计算能力的问题分配给网络上多台计算机进行解决。 可能比较重要的HDFSHDFS，即Hadoop分布式文件系统，是一个使用Java语言进行编写的分布式的文件系统。一个HDFS集群一般由一个NameNode和若干DataNode组成。简单来说NameNode负责管理元信息（关于信息的信息），DataNode负责管理数据块。 MapReduce又是什么？MapReduce是由google提出的用于处理大规模数据集的计算模型，运行在HDFS之上。它包括JobTracker和TaskTracker两个主要组成部分，分别运行在NameNode和DataNode上。用户提交的数据处理请求称为Job，JobTracker将其分解成数据处理任务Task，分配给相关节点上的TaskTracker处理。 MapReduce模型简介 MapReduce将复杂的、运行于大规模集群上的并行计算过程高度地抽象到了两个函数： Map和Reduce 在MapReduce中，一个存储在分布式文件系统中的大规模数据集，会被切分成许多独立的 小数据块，这些小数据块可以被多个Map任务并行处理 MapReduce框架会为每个Map任务输入一个数据子集，Map任务生成的结果会继续作为 Reduce任务的输入，最终由Reduce任务输出最后结果，并写入到分布式文件系统中 MapReduce的工作过程 先从HDFS文件系统中读取数据 将读取的数据进行预处理后进行切分Split 通过RecordReader根据InputSplit中的信息处理其中的记录，加载数据并转换为合适Map任务读取的键值 Map阶段：将原始数据集解析成一批键值对 Shuffle： Shuffle横跨Map端和Reduce端，即Map shuffle和Reduce shuffle。在Map shuffle中对Map的结果进行分区、排序、合并。在Reduce shuffle中，Reduce领取数据放入缓存，归并合并后写入硬盘。 Reduce阶段：对每一批具有相同键的键值对进行输出 实例分析——实现关系的自然连接思路分析对于关系R(A,B)和S(B,C)，输出T(B,A,C) 在map过程中，将R中的每个元组转换成&lt;b,&lt;R,a&gt;&gt;，将S中的每个元组转换成&lt;b,&lt;R,c&gt;&gt;。所有具有相同B值的元组在同一个reduce进程中被合并，输出连接后的元组&lt;a,b,c&gt;。 实例给定了两个xlsx格式的表格，直接处理过于复杂。可以先借助POI等库或者手动转换文件格式至纯文本的csv(代码中包含对xlsx进行格式转换的类)。 在hadoop框架实现简单自然连接的操作很简单，只需要自定义mapper类和reducer类即可。 主类： 12345678910111213141516171819public class Driver &#123; public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException &#123; Configuration conf = new Configuration();//加载配置文件,如有改动则覆盖默认配置 Job job = Job.getInstance(conf);//根据配置信息实例化job对象 job.setJarByClass(Driver.class); //设置job的主入口程序 //设置mapper类 job.setMapperClass(MyMapper.class); //设置reducer类 job.setReducerClass(MyReducer.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(Text.class); FileInputFormat.setInputPaths(job, new Path(&quot;/home/hadoop/Documents/data&quot;)); FileOutputFormat.setOutputPath(job, new Path(&quot;/home/hadoop/Documents/dataOutput&quot;)); boolean result = job.waitForCompletion(true); System.exit(result ? 0 : 1); &#125;&#125; mapper类： 12345678910111213141516171819202122232425262728293031public class MyMapper extends Mapper&lt;LongWritable, Text, Text, Text&gt; &#123;//这里定义了一个mapper类，其中有一个map方法。MapReduce框架每读到一行数据，就会调用一次这个map方法。 @Override protected void map(LongWritable key,Text value,Mapper&lt;LongWritable, Text, Text, Text&gt;.Context context) throws IOException,InterruptedException&#123; /* 其中key是传入map的键值，value是对应键值的value值，context是环境对象变量，供程序访问Hadoop的环境参数 map方法对输入的键值对进行处理，产生一系列的中间键值对，转换后的中间键值对可以有新的键值类型。 输入的键值对可根据实际应用设定，例如文档数据记录可将文本文件中的行或数据表格中的行设为key，对应行的类容为value */ Text outKey = new Text(); Text outValue = new Text(); FileSplit fileSplit = (FileSplit) context.getInputSplit(); String filePath = fileSplit.getPath().toString(); String line = value.toString(); //输出键值对中的值加入&quot;student&quot;/&quot;student_course&quot;字段的目的是能够在reduce阶段对键值对的来源进行判断从而进行不同的处理 //切割表格时的切割份数与输出时选用的部分对应题目要求 if (filePath.contains(&quot;student.csv&quot;))&#123; String[] allS = line.split(&quot;,&quot;,3); outKey.set(allS[0]); outValue.set(&quot;student&quot;+&quot; &quot;+allS[1]); &#125; else if (filePath.contains(&quot;student_course.csv&quot;))&#123; String[] allC = line.split(&quot;,&quot;,4); outKey.set(allC[0]); outValue.set(&quot;student_course&quot; + &quot; &quot; + allC[1]+&quot;,&quot;+allC[2]); &#125; context.write(outKey,outValue); &#125;&#125; 需要注意，在Hadoop中并没有使用java的基本类型类，而是使用自己开发的类。详细内容可以查看这篇博文hadoop中典型Writable类详解。 reducer类： 123456789101112131415161718192021222324public class MyReducer extends Reducer&lt;Text, Text, Text, Text&gt; &#123; private ArrayList&lt;String&gt; record = new ArrayList&lt;&gt;(); private final Text value = new Text(); private String name; @Override protected void reduce(Text key,Iterable&lt;Text&gt; values,Reducer&lt;Text,Text,Text,Text&gt;.Context context) throws IOException, InterruptedException &#123; record = new ArrayList&lt;&gt;(); for (Text val : values)&#123; String[] fields = StringUtils.split(val.toString(),&#x27; &#x27;); String flag = fields[0]; //判断键值对来自哪一个表格，进行相应处理 if (flag.equals(&quot;student&quot;))&#123; name = fields[1]; &#125; else if (flag.equals(&quot;student_course&quot;))&#123; record.add(fields[1]); &#125; &#125; for (String i:record)&#123; value.set(name+&quot;,&quot;+i); context.write(key,value); &#125; &#125;&#125;"},{"title":"Hexo | 记录一下建立这个博客的过程","path":"2021/11/07/记录一下建立这个博客的过程/","text":"历时13天，本博客终于基本施工完成了。博客的第一篇文就简单记录一下对前端零了解的我瞎折腾的过程。 基础功能说说/artitalk.js起初看到一个typecho博主实现了这个功能，不过似乎是通过微信公众号发布说说，然后将内容嵌入的博客中。稍微搜索了一下没有找到相关的教程，而且好像整微信公众号什么的似乎也很麻烦，就放弃了这个想法。 经过一小段时间的搜索，我发现Artitalk.js就很符合我的需求。 Artitalk.js是基于 LeanCloud 实现的可实时发布说说/微语的 js 增删查改全方面支持 支持针对每条说说的评论 支持 Markdown/html 语法 支持图片上传 使用也很简单，注册一个LeanCloud国际版账号，按照使用说明的教程进行配置。然后新建一个post，直接在其中添加 12345678&lt;script type=&quot;text/javascript&quot; src=&quot;https://unpkg.com/artitalk&quot;&gt;&lt;/script&gt;&lt;div id=&quot;artitalk_main&quot;&gt;&lt;/div&gt;&lt;script&gt;new Artitalk(&#123; appId: &#x27;&#x27;, // Your LeanCloud appId appKey: &#x27;&#x27; // Your LeanCloud appKey&#125;)&lt;/script&gt; 发布界面后就可以看到配置成功的提示了。 一个小问题：加载动画与说说容器上方的内容有重叠后面将content容器的背景改为半透明时，发现加载动画背景有白块，很丑，于是干脆把加载动画关掉了 不怎么会用typora，本想着用空格什么的占位符让加载动画和上方的分割线空出些距离，但这样会产生一部分能选中的文本，本强迫症无法接受，于是怒打开ps，做了一个细长的全透明图片，插在分割线和说说容器之间。 虽然稍微有些蠢，但不也挺好的吗（ 加载动画：没注意大小啊在把content容器的背景改为半透明之后，输入框里的新科娘的白色背景十分刺眼。找了张ほし老师的Q版画，抠图，传图床，看实际效果的时候发现图好大（ 于是去github删掉图片，ps里调整大小和位置，又重新上传了一下，但是cdn的刷新有延迟，搜了一下刷新Jsdelivr缓存的方法，发现竟然还真有！ 把Jsdelivr链接中的cdn替换成purge 但即便刷新之后还是有大概10min的延迟，我就进行了3次处理上传-&gt;等待刷新-&gt;查看效果发现大小不行-&gt;处理上传的循环（ 反应过来以后我觉得我就是个啥宝，f12找出加载图的资源地址，直接查看这张图的大小不就行了吗（ 评论功能/valine-&gt;disqus-&gt;disqusjs一开始使用valine一是因为感觉用valine的真的很多，而且用起来很方便，只需要在LeanCloud中再建一个应用给评论就行。但是看valine的帮助文档的时候，发现真的有好多问题，不兼容pjax、自带的邮件提醒下线、第三方的邮件提醒的配置我看不懂（…… 后来看到别人博客的disqus，感觉不错于是我也换了disqus，注册了一个账号，修改了一下主题配置，感觉良好，还支持邮件提醒。但是！当我不科学上网时，发现评论区根本加载不出来（，这时候才发现原来disqus被墙了。 接着改用disqusjs，惊喜地发现在使用文档里有这么一句： DisqusJS v1.2.6 开始支持检测是否存在 Disqus 实例，并在加载 Disqus 时直接调用 DISQUS.reset() 方法重载 Disqus 评论，无需用户手动销毁现有的 Disqus 实例。 虽然不是很明白，但感觉应该就是不用根据pjax调整了吧（ 听说disqus是有广告的，但这都1202了，不会还有人没有adblock吧（ 美化与优化live2d看板娘起初参考的这篇文章:Hexo 博客优化之博客美化系列（持续更新） 虽然使用很简单但仅有一个冻鳗人物实在是没什么意思，翻了一会翻到了就发现了这个，支持换人换装和对话框。使用文档说的很多，我也看不太懂。就在layout中加了一句 1&lt;script src=&quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js&quot;&gt;&lt;/script&gt; 生成网页后有效果了，我就暂时搁置了。 但在整完pjax后，我发现我可以大致看懂使用文档了。 initWidget 方法接受名为 apiPath 和 cdnPath 的参数，两者设置其中一项即可。其中 apiPath 为后端 API 的 URL，可以自行搭建，并增加模型。 我找到了默认的后端api仓库，然后查看其fork列表，发现这个仓库被第二次fork的次数最多，于是我也fork了一下这个仓库，改了一点参数并删除了我不想要的模型，达成想要实现的效果了！ 音乐播放器耗时最长的东西其一。 初次接触时看着什么APlayer,Meting,hexo-tag-aplayer一头雾水，理不清谁是谁，有什么区别。甚至看不出他们的使用方法里写的是什么语言（ 所幸搜到了这篇博文，这我不就明白了吗（， 123456&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;my-aplayer&quot; class=&quot;aplayer&quot; &gt;&lt;/div&gt; 为其他配置项赋好值以后，把这段html代码加到页面中，成功得到一个在右侧顶端的音乐播放器。至少我用的nexmoe主题是这样 播放列表无法展开！怎么点播放列表也没反应啊，没有办法。我的第一个想法是通过自定义修改css和js文件把列表那个按钮给去掉！但是我当时还不知道怎么处理不在本地的css后来才知道可以下载后放在source文件夹中在把href值改成绝对路径，而且这个css的排版也乱的不行毫无可读性可以在页面f12找到对应按钮的css标签然后在本地搜索（。 于是我开始猜想打不开列表的原因。首先我想到我并没有调整css给播放器在页面上安排一个位置大概，但是播放器确如我所愿在content容器之上，那有没有一种可能是容器的大小被设定成了播放器的大小，列表展开后处在容器之外呢？ 打开f12，确实验证了我这个想法。 上网搜索css如何自适应高度，得到的方法是在style中设置display值为’table’，完美解决。 切换界面音乐就停了一开始让我用pjax我是拒绝的，因为其使用文档我一丁点也看不明白（ 在使用pjax之前，没刷新一次界面，看板娘也会跟着刷新一遍，我不以为意。但在整好音乐播放器以后这个问题就没法忽视了，这一切换页面音乐就停了也太蠢了。 于是被迫看懂看不懂的东西，耗时最长的东西其二就来了。 pjax pjax是基于ajax+pushState的新技术，该技术可以无刷新改变页面的内容，并且可以改变页面的URL。 初次尝试pjax时，按照其他博主的教程用npm安装，引入js，照猫画虎地写了一段（应该是php?）代码。但测试发现并没有任何效果。 1$(document).pjax(&#x27;a&#x27;, &#x27;#pjax-container&#x27;) 经过不懈的瞎努力尝试，终于明白这个容器参数前的’#’或’.’是有具体含义的。仔细阅读pjax的Usage后，了解到这就是css selector。 .x就是选择class值为x的元素 #y就是选择所有id值为y的元素 更改代码后终于成功实现了无刷新改变界面，但是此时出现了一个新问题。 pjax只支持刷新一个容器？？点击左侧的按钮，右侧的内容容器确实在无刷新改变。但是左侧的按钮，它状态不变了！！翻遍pjax的说明文档似乎并没有说如何刷新两个容器，百度无果，谷歌用英语终于搜到了答案：pjax不支持刷新两个容器！ 无奈，新建了一个标签将左侧和右侧，也就是header与content全部包裹在一起，这样的话每次启用pjax都会刷新按钮状态了。 jQuery过时了？在很多博主的文章里都能看到他们因为jQuery的原因舍弃了pjax，不过我在某一篇文章的评论区中看到有人说有大佬做出了不需要jQuery的pjax？ 正好当时在用的jQuery-pjax不知道为何一添加NProgress之类的就会彻底失效。抱着试试看的态度我删除了原来的pjax使用了MoOx/pjax。结果真的是超乎我的意料，不仅切换界面的流畅度大大提升，能够使用NProgress，支持多容器刷新，并且原来在一个界面停留时间过长pjax会失效的bug，以及窗口大小低时header部分会抽风的bug也解决了。唯一无伤大雅的缺点是网址上会多一个时间戳（ 还有一个bug（看到左侧的搜索栏了吗，这个搜索会重新刷新整个界面，暂时我还没找到解决方法捏（ 要不干脆改成站外搜索吧（ 动画特效/animate.css起初我看到一个搜图网站的加载动画做得非常好看，于是我就想偷借过来用一下（ f12打开控制台，只看见无数的js，我全部复制下来引用到自己的layout文件中，copy了看起来相关的css和html代码。最后发现这个加载动画，它停不下来啊！ 折腾了半天无果现在已经实现了阉割版，在我删掉引入的乱七八糟的js时我看见了这样一个名字的css：animate.min.css。 了解后发现网页的很多简单特效都可以用这个轻易完成。这里有动画效果演示。引入css后只需要在想要添加动画效果的容器的class中加上实例中的动画名称就可以了。 其他解决了一个又一个问题，我初步对css、js和html有了一丁点了解。在能够熟练地瞎改css后，我也成功将界面改成圆角并做成了蓝色半透明的感觉！ 本文完成时博客的界面： 在实现我的预期功能时，因个人能力原因妥协了很多，最终成品也是有很多不足，但我也十分满意了，在胡乱折腾的过程中也十分开心，希望以后我可以做得更好吧。"}]