[{"title":"python爬虫 | 爬虫的概念及学习python爬虫所需的一些前端基础","path":"2022/02/08/学习python爬虫所需的一些前端基础/","text":"之前学过一点爬虫但却没有实际操作过，最近心血来潮决定一定要掌握基本的爬虫程序编写。第一篇就简单记录复制一下爬虫的相关概念和学习爬虫所需的前端基础。 爬虫的基本概念和工作原理网络爬虫的基本概念网络爬虫是一种根据特定爬取规则，自动抓取网页，提取网页内容，输出特定数据的应用程序。主要功能有: 广泛收集网页信息，形成 web 检索 根据兴趣需求，聚焦具体内容，面向主题进行数据采集 针对特定 web 应用系统或处理流程，实现自动化测试或模型检测 针对 web 系统可能存在的风险或漏洞，实现自动化安全测试和漏洞检测 网络爬虫的构成部分 需要爬取的网页地址 执行爬取策略的任务调度器 访问页面或下载数据的下载器 分析和提取页面内容的解析器 保存爬得数据结果的存储器 爬虫的基本工作原理 由用户给定一组网页 URLs，作为爬虫程序的输入，爬虫程序会将它们存放在待爬取队列中。 调度器 (Scheduler) 会从待爬取 URL 队列中逐一取出 URL，判断该 URL 是否已经被爬取过，即执行去重判断，之后，按照一定的遍历策略或负载策略，对 URL 发起网络爬取任务，也就是执行相应的 HTTP 请求。 下载器将逐一执行调度器产生的每个 HTTP 请求, 下载对应的 Web 内容，返回结果包括:HTML 网页、CSS 文件、JavaScript、图片等等。 解析器对下载器获得的 HTML 页面内容进行解析，提取出用户关心的部分内容，这其中，既包括用户感兴趣的关键数据; 也包括有待下一步爬取的新的 URLs。 存储器负责按照一定的存储模式，将解析器提取得到的用户兴趣数据存储到文件或数据库中，以供后续数据分析和处理使用。 解析器提取的需要进一步爬取的新 URLs，会被送往待爬取 URLs 队列。 网络爬虫的功能需求 像浏览器一样，能够向网站服务器发出请求，获得 web 网页。 能够将 web 网页中有关主题的信息进行定位，然后提取出来。 能够将提取出的信息进行组织，有序存储到文件或数据库中。 能够发现新的与主题相关的网页，自动完成进一步的主题爬取。 爬虫相关web技术介绍相关web技术概述Web 是一种基于 HTML 和 HTTP 的全球性的分布式图形信息系统， 它是建立在 lnternet 上的一种网络服务。构成 web 的五大要素有： web 页面的统一资源定位符 (URL) 超文本传输协议 (HTTP) 超文本标记语言 (HTML Web 服务器 Web 浏览器 网络爬取的入口URL URL (Uniform Resource Locator) 意为统—资源定位符，具有唯一性和通用性。 唯一性：互联网上的每个文件都有一个唯一的 URL 通用性：URL 的构成遵循一定格式 URL 的格式分为 7 个部分: 访问模式 (或称通信协议)、用户信息、主机名称 (或 IP 地址)、访问端口、路径、查询、片段 URL=scheme:[//authority]path[?query][#fragment] 访问模式 (或称通信协议) ：指示服务器采用哪种协议或应用服务，来接收来自客户端的请求，并给予响应。例如 http、ftp 等。 用户信息 ：非必填，用户信息通常表现为用户名：用户密码，后加 @ 作为间隔符。 主机名称 (或 IP 地址) ：即 web 网页所在服务器的域名或是 IP 地址。 访问端口 ：非必填，服务器上某个正在运行的网络服务程序的访问地址。以整数形式标识，范围是 0~65535。 路径 ：路径由 1 个或多个“/”符号隔开的字符串组成，一般用来表示主机上的一个 web 访问目录或具体的文件路径。 查询 ：查询常用于向网站服务器传递参数，查询通常由? 开始，查询参数使用参数名 = 参数值的格式，有多个参数时，中间用 &amp;(and) 符号隔开。 片段 ：通常以一个 # 号开启，用于辅助定位。 未完待续"},{"title":"日语数量词的音变规则总结","path":"2021/11/19/日语数量词的音变规则总结/","text":"在学习日语的初级阶段我遇到的第一个困难便是日语众多的助数词了，各种各样与汉语不尽相同的量词及其音变着实让人头疼。 特撰写此文总结一下日语数量词的音变规则及声调变化。 开始要说音变规律，我们可以先从音变的种类说起。日语中的音变可以分为三类：促音变、浊音变和半浊音变。"},{"title":"Hadoop | Hadoop初体验——实现两个excel表格的自然连接","path":"2021/11/16/Hadoop初体验/","text":"一次Hadoop Mapreduce作业的完成过程 应该是第一次正儿八经地接触与大数据相关的东西，好多名词都看不明白。 记录一下我完成这次作业时的思考。 先放代码 题目： 在关系代数中，自然连接(Natural join)是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。 根据给定的数据《student.xlsx》和《student_course.xlsx》，请使用MapReduce计算模型，实现表student和表student_course的自然连接，结果集包括学生学号、姓名、选修课程编号、考试成绩。 什么是Hadoop？Hadoop是一个能够对大量数据进行分布式处理的软件框架。 Hadoop框架透明地为应用提供可靠性和数据移动。它实现了名为MapReduce的编程范型：应用程序被分割成许多小部分，而每个部分都能在集群中的任意节点上执行或重新执行。此外，Hadoop还提供了分布式文件系统，用以存储所有计算节点的数据，这为整个集群带来了非常高的带宽。MapReduce和分布式文件系统的设计，使得整个框架能够自动处理节点故障。它使应用程序与成千上万的独立计算的电脑和PB级的数据连接起来。现在普遍认为整个Apache Hadoop“平台”包括Hadoop内核、MapReduce、Hadoop分布式文件系统（HDFS）以及一些相关项目，有Apache Hive和Apache HBase等等。 那分布式又是什么呢？（ 简单来说就是就是将一个需要巨大计算能力的问题分配给网络上多台计算机进行解决。 可能比较重要的HDFSHDFS，即Hadoop分布式文件系统，是一个使用Java语言进行编写的分布式的文件系统。一个HDFS集群一般由一个NameNode和若干DataNode组成。简单来说NameNode负责管理元信息（关于信息的信息），DataNode负责管理数据块。 MapReduce又是什么？MapReduce是由google提出的用于处理大规模数据集的计算模型，运行在HDFS之上。它包括JobTracker和TaskTracker两个主要组成部分，分别运行在NameNode和DataNode上。用户提交的数据处理请求称为Job，JobTracker将其分解成数据处理任务Task，分配给相关节点上的TaskTracker处理。 MapReduce模型简介 MapReduce将复杂的、运行于大规模集群上的并行计算过程高度地抽象到了两个函数： Map和Reduce 在MapReduce中，一个存储在分布式文件系统中的大规模数据集，会被切分成许多独立的 小数据块，这些小数据块可以被多个Map任务并行处理 MapReduce框架会为每个Map任务输入一个数据子集，Map任务生成的结果会继续作为 Reduce任务的输入，最终由Reduce任务输出最后结果，并写入到分布式文件系统中 MapReduce的工作过程 先从HDFS文件系统中读取数据 将读取的数据进行预处理后进行切分Split 通过RecordReader根据InputSplit中的信息处理其中的记录，加载数据并转换为合适Map任务读取的键值 Map阶段：将原始数据集解析成一批键值对 Shuffle： Shuffle横跨Map端和Reduce端，即Map shuffle和Reduce shuffle。在Map shuffle中对Map的结果进行分区、排序、合并。在Reduce shuffle中，Reduce领取数据放入缓存，归并合并后写入硬盘。 Reduce阶段：对每一批具有相同键的键值对进行输出 实例分析——实现关系的自然连接思路分析对于关系R(A,B)和S(B,C)，输出T(B,A,C) 在map过程中，将R中的每个元组转换成&lt;b,&lt;R,a&gt;&gt;，将S中的每个元组转换成&lt;b,&lt;R,c&gt;&gt;。所有具有相同B值的元组在同一个reduce进程中被合并，输出连接后的元组&lt;a,b,c&gt;。 实例给定了两个xlsx格式的表格，直接处理过于复杂。可以先借助POI等库或者手动转换文件格式至纯文本的csv(代码中包含对xlsx进行格式转换的类)。 在hadoop框架实现简单自然连接的操作很简单，只需要自定义mapper类和reducer类即可。 主类： 12345678910111213141516171819public class Driver &#123; public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException &#123; Configuration conf = new Configuration();//加载配置文件,如有改动则覆盖默认配置 Job job = Job.getInstance(conf);//根据配置信息实例化job对象 job.setJarByClass(Driver.class); //设置job的主入口程序 //设置mapper类 job.setMapperClass(MyMapper.class); //设置reducer类 job.setReducerClass(MyReducer.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(Text.class); FileInputFormat.setInputPaths(job, new Path(&quot;/home/hadoop/Documents/data&quot;)); FileOutputFormat.setOutputPath(job, new Path(&quot;/home/hadoop/Documents/dataOutput&quot;)); boolean result = job.waitForCompletion(true); System.exit(result ? 0 : 1); &#125;&#125; mapper类： 12345678910111213141516171819202122232425262728293031public class MyMapper extends Mapper&lt;LongWritable, Text, Text, Text&gt; &#123;//这里定义了一个mapper类，其中有一个map方法。MapReduce框架每读到一行数据，就会调用一次这个map方法。 @Override protected void map(LongWritable key,Text value,Mapper&lt;LongWritable, Text, Text, Text&gt;.Context context) throws IOException,InterruptedException&#123; /* 其中key是传入map的键值，value是对应键值的value值，context是环境对象变量，供程序访问Hadoop的环境参数 map方法对输入的键值对进行处理，产生一系列的中间键值对，转换后的中间键值对可以有新的键值类型。 输入的键值对可根据实际应用设定，例如文档数据记录可将文本文件中的行或数据表格中的行设为key，对应行的类容为value */ Text outKey = new Text(); Text outValue = new Text(); FileSplit fileSplit = (FileSplit) context.getInputSplit(); String filePath = fileSplit.getPath().toString(); String line = value.toString(); //输出键值对中的值加入&quot;student&quot;/&quot;student_course&quot;字段的目的是能够在reduce阶段对键值对的来源进行判断从而进行不同的处理 //切割表格时的切割份数与输出时选用的部分对应题目要求 if (filePath.contains(&quot;student.csv&quot;))&#123; String[] allS = line.split(&quot;,&quot;,3); outKey.set(allS[0]); outValue.set(&quot;student&quot;+&quot; &quot;+allS[1]); &#125; else if (filePath.contains(&quot;student_course.csv&quot;))&#123; String[] allC = line.split(&quot;,&quot;,4); outKey.set(allC[0]); outValue.set(&quot;student_course&quot; + &quot; &quot; + allC[1]+&quot;,&quot;+allC[2]); &#125; context.write(outKey,outValue); &#125;&#125; 需要注意，在Hadoop中并没有使用java的基本类型类，而是使用自己开发的类。详细内容可以查看这篇博文hadoop中典型Writable类详解。 reducer类： 123456789101112131415161718192021222324public class MyReducer extends Reducer&lt;Text, Text, Text, Text&gt; &#123; private ArrayList&lt;String&gt; record = new ArrayList&lt;&gt;(); private final Text value = new Text(); private String name; @Override protected void reduce(Text key,Iterable&lt;Text&gt; values,Reducer&lt;Text,Text,Text,Text&gt;.Context context) throws IOException, InterruptedException &#123; record = new ArrayList&lt;&gt;(); for (Text val : values)&#123; String[] fields = StringUtils.split(val.toString(),&#x27; &#x27;); String flag = fields[0]; //判断键值对来自哪一个表格，进行相应处理 if (flag.equals(&quot;student&quot;))&#123; name = fields[1]; &#125; else if (flag.equals(&quot;student_course&quot;))&#123; record.add(fields[1]); &#125; &#125; for (String i:record)&#123; value.set(name+&quot;,&quot;+i); context.write(key,value); &#125; &#125;&#125;"},{"title":"Hexo | 记录一下建立这个博客的过程","path":"2021/11/07/记录一下建立这个博客的过程/","text":"历时13天，本博客终于基本施工完成了。博客的第一篇文就简单记录一下对前端零了解的我瞎折腾的过程。 基础功能说说/artitalk.js起初看到一个typecho博主实现了这个功能，不过似乎是通过微信公众号发布说说，然后将内容嵌入的博客中。稍微搜索了一下没有找到相关的教程，而且好像整微信公众号什么的似乎也很麻烦，就放弃了这个想法。 经过一小段时间的搜索，我发现Artitalk.js就很符合我的需求。 Artitalk.js是基于 LeanCloud 实现的可实时发布说说/微语的 js 增删查改全方面支持 支持针对每条说说的评论 支持 Markdown/html 语法 支持图片上传 使用也很简单，注册一个LeanCloud国际版账号，按照使用说明的教程进行配置。然后新建一个post，直接在其中添加 12345678&lt;script type=&quot;text/javascript&quot; src=&quot;https://unpkg.com/artitalk&quot;&gt;&lt;/script&gt;&lt;div id=&quot;artitalk_main&quot;&gt;&lt;/div&gt;&lt;script&gt;new Artitalk(&#123; appId: &#x27;&#x27;, // Your LeanCloud appId appKey: &#x27;&#x27; // Your LeanCloud appKey&#125;)&lt;/script&gt; 发布界面后就可以看到配置成功的提示了。 一个小问题：加载动画与说说容器上方的内容有重叠后面将content容器的背景改为半透明时，发现加载动画背景有白块，很丑，于是干脆把加载动画关掉了 不怎么会用typora，本想着用空格什么的占位符让加载动画和上方的分割线空出些距离，但这样会产生一部分能选中的文本，本强迫症无法接受，于是怒打开ps，做了一个细长的全透明图片，插在分割线和说说容器之间。 虽然稍微有些蠢，但不也挺好的吗（ 加载动画：没注意大小啊在把content容器的背景改为半透明之后，输入框里的新科娘的白色背景十分刺眼。找了张ほし老师的Q版画，抠图，传图床，看实际效果的时候发现图好大（ 于是去github删掉图片，ps里调整大小和位置，又重新上传了一下，但是cdn的刷新有延迟，搜了一下刷新Jsdelivr缓存的方法，发现竟然还真有！ 把Jsdelivr链接中的cdn替换成purge 但即便刷新之后还是有大概10min的延迟，我就进行了3次处理上传-&gt;等待刷新-&gt;查看效果发现大小不行-&gt;处理上传的循环（ 反应过来以后我觉得我就是个啥宝，f12找出加载图的资源地址，直接查看这张图的大小不就行了吗（ 评论功能/valine-&gt;disqus-&gt;disqusjs一开始使用valine一是因为感觉用valine的真的很多，而且用起来很方便，只需要在LeanCloud中再建一个应用给评论就行。但是看valine的帮助文档的时候，发现真的有好多问题，不兼容pjax、自带的邮件提醒下线、第三方的邮件提醒的配置我看不懂（…… 后来看到别人博客的disqus，感觉不错于是我也换了disqus，注册了一个账号，修改了一下主题配置，感觉良好，还支持邮件提醒。但是！当我不科学上网时，发现评论区根本加载不出来（，这时候才发现原来disqus被墙了。 接着改用disqusjs，惊喜地发现在使用文档里有这么一句： DisqusJS v1.2.6 开始支持检测是否存在 Disqus 实例，并在加载 Disqus 时直接调用 DISQUS.reset() 方法重载 Disqus 评论，无需用户手动销毁现有的 Disqus 实例。 虽然不是很明白，但感觉应该就是不用根据pjax调整了吧（ 听说disqus是有广告的，但这都1202了，不会还有人没有adblock吧（ 美化与优化live2d看板娘起初参考的这篇文章:Hexo 博客优化之博客美化系列（持续更新） 虽然使用很简单但仅有一个冻鳗人物实在是没什么意思，翻了一会翻到了就发现了这个，支持换人换装和对话框。使用文档说的很多，我也看不太懂。就在layout中加了一句 1&lt;script src=&quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js&quot;&gt;&lt;/script&gt; 生成网页后有效果了，我就暂时搁置了。 但在整完pjax后，我发现我可以大致看懂使用文档了。 initWidget 方法接受名为 apiPath 和 cdnPath 的参数，两者设置其中一项即可。其中 apiPath 为后端 API 的 URL，可以自行搭建，并增加模型。 我找到了默认的后端api仓库，然后查看其fork列表，发现这个仓库被第二次fork的次数最多，于是我也fork了一下这个仓库，改了一点参数并删除了我不想要的模型，达成想要实现的效果了！ 音乐播放器耗时最长的东西其一。 初次接触时看着什么APlayer,Meting,hexo-tag-aplayer一头雾水，理不清谁是谁，有什么区别。甚至看不出他们的使用方法里写的是什么语言（ 所幸搜到了这篇博文，这我不就明白了吗（， 123456&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;my-aplayer&quot; class=&quot;aplayer&quot; &gt;&lt;/div&gt; 为其他配置项赋好值以后，把这段html代码加到页面中，成功得到一个在右侧顶端的音乐播放器。至少我用的nexmoe主题是这样 播放列表无法展开！怎么点播放列表也没反应啊，没有办法。我的第一个想法是通过自定义修改css和js文件把列表那个按钮给去掉！但是我当时还不知道怎么处理不在本地的css后来才知道可以下载后放在source文件夹中在把href值改成绝对路径，而且这个css的排版也乱的不行毫无可读性可以在页面f12找到对应按钮的css标签然后在本地搜索（。 于是我开始猜想打不开列表的原因。首先我想到我并没有调整css给播放器在页面上安排一个位置大概，但是播放器确如我所愿在content容器之上，那有没有一种可能是容器的大小被设定成了播放器的大小，列表展开后处在容器之外呢？ 打开f12，确实验证了我这个想法。 上网搜索css如何自适应高度，得到的方法是在style中设置display值为’table’，完美解决。 切换界面音乐就停了一开始让我用pjax我是拒绝的，因为其使用文档我一丁点也看不明白（ 在使用pjax之前，没刷新一次界面，看板娘也会跟着刷新一遍，我不以为意。但在整好音乐播放器以后这个问题就没法忽视了，这一切换页面音乐就停了也太蠢了。 于是被迫看懂看不懂的东西，耗时最长的东西其二就来了。 pjax pjax是基于ajax+pushState的新技术，该技术可以无刷新改变页面的内容，并且可以改变页面的URL。 初次尝试pjax时，按照其他博主的教程用npm安装，引入js，照猫画虎地写了一段（应该是php?）代码。但测试发现并没有任何效果。 1$(document).pjax(&#x27;a&#x27;, &#x27;#pjax-container&#x27;) 经过不懈的瞎努力尝试，终于明白这个容器参数前的’#’或’.’是有具体含义的。仔细阅读pjax的Usage后，了解到这就是css selector。 .x就是选择class值为x的元素 #y就是选择所有id值为y的元素 更改代码后终于成功实现了无刷新改变界面，但是此时出现了一个新问题。 pjax只支持刷新一个容器？？点击左侧的按钮，右侧的内容容器确实在无刷新改变。但是左侧的按钮，它状态不变了！！翻遍pjax的说明文档似乎并没有说如何刷新两个容器，百度无果，谷歌用英语终于搜到了答案：pjax不支持刷新两个容器！ 无奈，新建了一个标签将左侧和右侧，也就是header与content全部包裹在一起，这样的话每次启用pjax都会刷新按钮状态了。 jQuery过时了？在很多博主的文章里都能看到他们因为jQuery的原因舍弃了pjax，不过我在某一篇文章的评论区中看到有人说有大佬做出了不需要jQuery的pjax？ 正好当时在用的jQuery-pjax不知道为何一添加NProgress之类的就会彻底失效。抱着试试看的态度我删除了原来的pjax使用了MoOx/pjax。结果真的是超乎我的意料，不仅切换界面的流畅度大大提升，能够使用NProgress，支持多容器刷新，并且原来在一个界面停留时间过长pjax会失效的bug，以及窗口大小低时header部分会抽风的bug也解决了。唯一无伤大雅的缺点是网址上会多一个时间戳（ 还有一个bug（看到左侧的搜索栏了吗，这个搜索会重新刷新整个界面，暂时我还没找到解决方法捏（ 要不干脆改成站外搜索吧（ 动画特效/animate.css起初我看到一个搜图网站的加载动画做得非常好看，于是我就想偷借过来用一下（ f12打开控制台，只看见无数的js，我全部复制下来引用到自己的layout文件中，copy了看起来相关的css和html代码。最后发现这个加载动画，它停不下来啊！ 折腾了半天无果现在已经实现了阉割版，在我删掉引入的乱七八糟的js时我看见了这样一个名字的css：animate.min.css。 了解后发现网页的很多简单特效都可以用这个轻易完成。这里有动画效果演示。引入css后只需要在想要添加动画效果的容器的class中加上实例中的动画名称就可以了。 其他解决了一个又一个问题，我初步对css、js和html有了一丁点了解。在能够熟练地瞎改css后，我也成功将界面改成圆角并做成了蓝色半透明的感觉！ 本文完成时博客的界面： 在实现我的预期功能时，因个人能力原因妥协了很多，最终成品也是有很多不足，但我也十分满意了，在胡乱折腾的过程中也十分开心，希望以后我可以做得更好吧。"}]