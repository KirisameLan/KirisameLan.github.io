[{"title":"NLP|N.自然语言处理导论","path":"posts/f836/","text":"其实本来想写数据可视化的作业的，但想了想好像也没什么好写的（ 正好暑假报了节十分水的入门NLP课，正好写篇入门文章节选一部分当成作业。之后不出意外应该会继续学习NLP。 自然语言处理概念NLP(Natural Language Processing)，即自然语言处理，是计算机科学领域与人工智能领域中的一个重要方向，研究用电子计算机模拟人的语言交际过程，使计算机能理解和运用人类社会的自然语言如汉语、英语等，实现人机之间的自然语言通信，以代替人的部分脑力劳动，包括查询资料、解答问题、摘录文献、汇编资料以及一切有关自然语言信息的加工处理。NLP的应用举例： 语音识别 文本挖掘 文本摘要 问答：通过信息检索和阅读理解算法回答用户给出的问题 机器翻译 语言训练：拼写&#x2F;语法纠错 NLP的困难歧义词汇级歧义以一个老古董搞笑视频举例,视频中的Siri将pie(数学中的π)的语音误识别为可食用的派，这里就体现了一词多义造成的歧义。 再比如英文单词&quot;design&quot;既可以为动词也可以为名词，词性上的不确定也会为NLP过程带来麻烦。 语法级歧义&quot;natural language processing&quot; 自然语言的处理or自然的语言处理？ &quot;Get the cat with the gloves&quot; 抓住那只带着手套的猫猫（？ 代词指代歧义 一个老段子： if exists(tomato){ ​ buyTomato(2) or buyWatermelon(2)?? } &quot;John persuaded Bill to buy a TV for himself.&quot; himself是指John还是Bill呢？ 人工智能完备AI-complete 图灵测试：如果一个人（代号 C）使用测试对象皆理解的语言去询问两个他不能看见的对象任意一串问题。对象为：一个是正常思维的人（代号 B）、一个是机器（代号 A）。如果经过若干询问以后，C 不能得出实质的区别来分辨 A 与 B 的不同，则此机器 A 通过图灵测试。 咖啡测试：生活中空间、操作技能的测试。将一部机器带到任何一个普通的美国家庭中，让它在不经刻意设计的条件下，懂得泡好一杯咖啡。它需要主动在陌生空间中认识咖啡机、辨识咖啡和水、找到合适的杯子并放好，然后按正确的键和操作以冲泡咖啡。这需要仰赖机器人学、图像辨识的演算。 机器人学生测试：透过机器学习，分析和回答单一问题的测试 。让一个机器去注册一所大学，参加和人类学生同样的考试，然后通过并获得学位。例如日本的东大 AI 或是 IBM 参加抢答节目的华生。 雇员测试：由尼尔森提出，其被用于测试统筹、推断、发想、规划解决复杂问题的能力。让机器处在一个经济上重要的职位，需要它能够和同样职位的人类做得同样好或者更好。 如果可以解决这些测试，那么就认定该人工智能属于强人工智能，也就是和人类一样聪明，称之为「人工智能完备」。 NLP的不同层级字符序列 &quot;To be or not to be.&quot; [&#39;T&#39;, &#39;o&#39;, &#39; &#39;, &#39;b&#39;, &#39;e&#39;, &#39; &#39;, &#39;o&#39;, &#39;r&#39;, &#39; &#39;, &#39;n&#39;, &#39;o&#39;, &#39;t&#39;, &#39; &#39;, &#39;t&#39;, &#39;o&#39;, &#39; &#39;, &#39;b&#39;, &#39;e&#39;, &#39;.&#39;] 将语句分割成字符序列后语义被完全破坏，无法进行语义分析，不过字符序列可以用于压缩。 词语序列 &quot;To be or not to be.&quot; [&#39;To&#39;, &#39;be&#39;, &#39;or&#39;, &#39;not&#39;, &#39;to&#39;, &#39;be&#39;] 其中高频词汇可被用来帮助进行主题建模（Topic Modeling） 在英语中很容易得到并处理词语序列，但在其他语言就不一定了。 世界上最长的单词lentokonesuihkuturbiinimoottoriapumekaanikkoaliupseerioppilas(芬兰语:飞机喷气涡轮发动机辅助机械士官学生)由10个词lento&#x2F;kone&#x2F;suihku&#x2F;turbiini&#x2F;moottori&#x2F;apu&#x2F;mekaanikko&#x2F;ali&#x2F;upseeri&#x2F;oppilas组成。 NLTK(Natural Language Toolkit)，自然语言处理工具包，在NLP领域中，最常使用的一个Python库。 图最后部分为使用NLKT计算词频。 马尔科夫模型马尔科夫过程马尔科夫过程(Markov process)是一类随机过程，该过程具有如下特性：在已知目前状态的条件下，它的未来状态不依赖于它过去的状态。 数学语言：设X(t),t∈T{X(t),t\\in T}X(t),t∈T为一随机过程，EEE为其状态空间，若对任意的t1&lt;t2&lt;⋯&lt;tn&lt;tt_1&lt;t_2&lt;\\cdots&lt;t_n&lt;tt1​&lt;t2​&lt;⋯&lt;tn​&lt;t，任意的x1,x2,⋯ ,xn,x∈Ex_1,x_2,\\cdots,x_n,x\\in Ex1​,x2​,⋯,xn​,x∈E，随机变量X(t)X(t)X(t)在已知变量X(t1)=x1,⋯ ,X(tn)=xnX(t_1)=x_1,\\cdots,X(t_n)=x_nX(t1​)=x1​,⋯,X(tn​)=xn​之下的条件分布函数只与X(tn)=xnX(t_n)=x_nX(tn​)=xn​有关，而与X(t1)=x1,⋯ ,X(tn−1=xn−1)X(t_1)=x_1,\\cdots,X(t_{n-1}=x_{n-1})X(t1​)=x1​,⋯,X(tn−1​=xn−1​)无关，即条件分布函数满足等式 F(x,t∣xn,xn−1,⋯ ,x2,x1,tn,tn−1,⋯ ,t2,t1)=F(x,t∣xn,tn)F(x,t|x_n,x_{n-1},\\cdots,x_2,x_1,t_n,t_{n-1},\\cdots,t_2,t_1)=F(x,t|x_n,t_n)F(x,t∣xn​,xn−1​,⋯,x2​,x1​,tn​,tn−1​,⋯,t2​,t1​)=F(x,t∣xn​,tn​) 此性质称为马尔科夫性，满足该性质的过程即为马尔科夫过程。 简单来说一个马尔科夫过程就是指过程中的每个状态的转移只依赖于之前的n个状态，这个过程被称为n阶马尔科夫模型，其中n是影响转移状态的数目。最简单的马尔科夫过程就是一阶过程，每一个状态的转移只依赖于其之前的那一个状态。 https://www.cs.helsinki.fi/u/ttonteri/ ←这个网站最下方的剪刀石头布游戏就是利用马尔科夫过程来预测对手的下一步。 统计语言模型(Statistical Language Model)统计语言模型是用来描述词、语句乃至于整个文档这些不同的语法单元的概率分布的模型。 模型词语序列（句子）w1,w2,w3,⋯ ,wnw_1,w_2,w_3,\\cdots,w_nw1​,w2​,w3​,⋯,wn​出现的概率：p(w1,w2,w3,⋯ ,wn)=p(w1)p(w2∣w1)p(w3∣w1w2)p(w4∣w1w2w3)⋯⋯p(wn∣w1w2w3⋯⋯wn−1)p(w_1,w_2,w_3,\\cdots,w_n)=p(w_1)p(w_2|w_1)p(w_3|w_1w_2)p(w_4|w_1w_2w_3)_{\\cdots\\cdots} p(w_n|w_1w_2w_{3\\cdots\\cdots}w_{n-1})p(w1​,w2​,w3​,⋯,wn​)=p(w1​)p(w2​∣w1​)p(w3​∣w1​w2​)p(w4​∣w1​w2​w3​)⋯⋯​p(wn​∣w1​w2​w3⋯⋯​wn−1​) 内容依赖 在通常的语言环境中， p(p(p(\"Today is Wednesday\")≈0.001)\\approx0.001)≈0.001 p(p(p(\"The equation has a solution\")≈0.00001)\\approx0.00001)≈0.00001 p(p(p(\"Today is Wednesday\")&gt;p()&gt;p()&gt;p(The equation has a solution\"))) 而如果是在一场数学相关的会议上 p(p(p(\"Today is Wednesday\")&lt;p()&lt;p()&lt;p(The equation has a solution\"))) 缺点过于复杂，假设我们的词典里只有三个词a,b,ca,b,ca,b,c，那么句子的最大长度为3，可能生成的句子就有333^333个。 a,b,c,ab,ac,aa,ba,bc,bb,ca,cb,cc,abc,acb,aab,⋯a,b,c,ab,ac,aa,ba,bc,bb,ca,cb,cc,abc,acb,aab,\\cdotsa,b,c,ab,ac,aa,ba,bc,bb,ca,cb,cc,abc,acb,aab,⋯ 为了解决这个问题，简化模型N-gram就被提出了。 N-gram今天先写到这"},{"title":"20岁，一切从零","path":"posts/273f/","text":"重新来过，只希望能在未来的道路上看见光明 先说说我自己大学时光真的过的特别快，不经意间已经从高中毕业近两年了。 但是我仍然在迷茫着，依旧在以悲观的角度看事，时常会做回到高中的噩梦，常常感慨自己竟然能撑过那段黑暗的日子。 有一天，我突然觉得 “不能再这样下去了”。 以某个已经忘掉的梦为契机，我下定了决心，尽力不再去回忆过去的自己。退掉了以前所有的班级群，把qq上的同学清洗了一遍，好友数仅剩下原来的一半，剩下的都是不舍得删掉的人，不过，也许之后还会更少吧。可能很多人不会认同我这种行为，我也明白我做的并不对，但我感觉我不得不这样与过去做一个决断，而且交情很深的几位我是不会删掉的。 同时我也注销掉了注册快十年，承载着我无数回忆以及黑历史的百度账号，虽然已经有两个小号而且又注册了一个，但是我和贴吧的缘分估计也就到此了吧。 尽力做一些更有意义的事情我对自己一直是一个结果主义者。 高中时，父亲常对我说，“不必在乎结果如何，你只要努力过了就可以了。” 我不认同。 人的努力得不到回报是如此可悲的事啊。 决不能把时间和努力付出在无意义的事上。 我在学校的集会上埋头刷题，对在台上胡言着的“成功学大师“嗤之以鼻，嘲笑着周围喝点鸡汤就能燃起三分钟热度的同学。 虽然过程中做了一些无法预测结果的无用功，高考的结果也不尽人意，不过我也可以说我没有对高中下半段的选择后悔。 大学生活的时间比起中学来说过于充裕，似乎让我有点过于放纵。每次在不知不觉中就在看网络垃圾中浪费了本可以玩游戏放松的时间。 在重新审视我的上网冲浪习惯后，我卸掉了贴吧，打开知乎的频率也越来越低。娱乐的话，偶尔玩点游戏就够了。成日看些交流平台不会让自己获得太多愉悦感，想要从中学些什么更是*里淘金。 既然是新的开始，那就先从不再键政，把时间留给自我提高上做起吧。 未来，会怎么样呢？这一年，能确实感觉到自己的情商略有提高。 久违地新交了几个朋友，虽然仍然不会聊天不会说话，不过也正因如此我更感激能接纳这样的我的他们。 仍然没有对未来的规划。迷茫着。不论是考研、就业，亦还是出国，我都没有做任何的准备。 不过，为了不让家人朋友伤心，还是得积极地面对生活。 一面に咲いた花と 晴れた世界は綺麗だ 苦しむことはもうないだろう 只愿能在未来的道路上看见光明。 祝自己生日快乐花了好多钱在dd上买专，就和刚买的ipad一起当做给自己的生日礼物吧ww"},{"title":"Hexo | 插件推荐——abbrlink 基于文章标题生成静态文章链接","path":"posts/9003/","text":"Hexo博客的博文链接与md文件的文件名一致，这就导致了一个问题：是采用缩略的英文名命名文件还是采用中文名命名文件呢？ 英文名命名会导致文章列表缺少直观可读性，中文文件名则会导致链接又臭又长且不利于网站的SEO。而abbrlink这个插件能很好地解决这个问题。 abbrlink的github仓库：https://github.com/rozbo/hexo-abbrlink 安装在博客根目录执行 1npm install hexo-abbrlink --save 更改配置打开_config.yml文件，将其中的 12permalink: :year/:month/:day/:title/permalink_defaults: 改为 123456#permalink: :year/:month/:day/:title/#permalink_defaults:permalink: posts/:abbrlink/abbrlink: alg: crc16 #support crc16(default) and crc32 rep: dec #support dec(default) and hex 设置alg项对应随机值算法参数，可选值为crc16和crc32。 rep项表示对应生成链接的表示方法，hex为16进制，dec为十进制。 采取不同设置生成的链接会有较大差异： 1234567891011crc16 &amp; hexhttps://post.zz173.com/posts/66c8.htmlcrc16 &amp; dechttps://post.zz173.com/posts/65535.htmlcrc32 &amp; hexhttps://post.zz173.com/posts/8ddf18fb.htmlcrc32 &amp; dechttps://post.zz173.com/posts/1690090958.html 重新部署执行 12$ hexo clean &amp; hexo g$ hexo d 会以标题作为种子为每篇文章生成一个id并保存在文章的font-matter中。 注意事项对于crc16编码，posts的最大值为65535。 该插件的作者还制作了另一个同功能插件abbrlink2，与abbrlink的不同是abbrlink2是以一个可自定义的初始值开始逐一递增的数值生成链接。例如： 123https://post.zz173.com/posts/1.htmlhttps://post.zz173.com/posts/2.htmlhttps://post.zz173.com/posts/3.html"},{"title":"python爬虫 | 爬虫的概念及学习python爬虫所需的一些前端基础","path":"posts/f587354b/","text":"之前学过一点爬虫但却没有实际操作过，最近心血来潮决定一定要掌握基本的爬虫程序编写。第一篇就简单记录复制一下爬虫的相关概念和学习爬虫所需的前端基础。 爬虫的基本概念和工作原理网络爬虫的基本概念网络爬虫是一种根据特定爬取规则，自动抓取网页，提取网页内容，输出特定数据的应用程序。主要功能有: 广泛收集网页信息，形成 web 检索 根据兴趣需求，聚焦具体内容，面向主题进行数据采集 针对特定 web 应用系统或处理流程，实现自动化测试或模型检测 针对 web 系统可能存在的风险或漏洞，实现自动化安全测试和漏洞检测 网络爬虫的构成部分 需要爬取的网页地址 执行爬取策略的任务调度器 访问页面或下载数据的下载器 分析和提取页面内容的解析器 保存爬得数据结果的存储器 爬虫的基本工作原理 由用户给定一组网页 URLs，作为爬虫程序的输入，爬虫程序会将它们存放在待爬取队列中。 调度器 (Scheduler) 会从待爬取 URL 队列中逐一取出 URL，判断该 URL 是否已经被爬取过，即执行去重判断，之后，按照一定的遍历策略或负载策略，对 URL 发起网络爬取任务，也就是执行相应的 HTTP 请求。 下载器将逐一执行调度器产生的每个 HTTP 请求, 下载对应的 Web 内容，返回结果包括:HTML 网页、CSS 文件、JavaScript、图片等等。 解析器对下载器获得的 HTML 页面内容进行解析，提取出用户关心的部分内容，这其中，既包括用户感兴趣的关键数据; 也包括有待下一步爬取的新的 URLs。 存储器负责按照一定的存储模式，将解析器提取得到的用户兴趣数据存储到文件或数据库中，以供后续数据分析和处理使用。 解析器提取的需要进一步爬取的新 URLs，会被送往待爬取 URLs 队列。 网络爬虫的功能需求 像浏览器一样，能够向网站服务器发出请求，获得 web 网页。 能够将 web 网页中有关主题的信息进行定位，然后提取出来。 能够将提取出的信息进行组织，有序存储到文件或数据库中。 能够发现新的与主题相关的网页，自动完成进一步的主题爬取。 爬虫相关web技术介绍相关web技术概述Web 是一种基于 HTML 和 HTTP 的全球性的分布式图形信息系统， 它是建立在 internet 上的一种网络服务。构成 web 的五大要素有： web 页面的统一资源定位符 (URL) 超文本传输协议 (HTTP) 超文本标记语言 (HTML) Web 服务器 Web 浏览器 网络爬取的入口URL URL (Uniform Resource Locator) 意为统—资源定位符，具有唯一性和通用性。 唯一性：互联网上的每个文件都有一个唯一的 URL 通用性：URL 的构成遵循一定格式 URL 的格式分为 7 个部分: 访问模式 (或称通信协议)、用户信息、主机名称 (或 IP 地址)、访问端口、路径、查询、片段 URL&#x3D;scheme:[&#x2F;&#x2F;authority]path[?query][#fragment] 访问模式 (或称通信协议) ：指示服务器采用哪种协议或应用服务，来接收来自客户端的请求，并给予响应。例如 http、ftp 等。 用户信息 ：非必填，用户信息通常表现为用户名：用户密码，后加 @ 作为间隔符。 主机名称 (或 IP 地址) ：即 web 网页所在服务器的域名或是 IP 地址。 访问端口 ：非必填，服务器上某个正在运行的网络服务程序的访问地址。以整数形式标识，范围是 0~65535。 路径 ：路径由 1 个或多个“&#x2F;”符号隔开的字符串组成，一般用来表示主机上的一个 web 访问目录或具体的文件路径。 查询 ：查询常用于向网站服务器传递参数，查询通常由? 开始，查询参数使用参数名 &#x3D; 参数值的格式，有多个参数时，中间用 &amp;(and) 符号隔开。 片段 ：通常以一个 # 号开启，用于辅助定位。 网页下载的原理超文本传输协议超文本传输协议是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。 HTTP的工作原理：HTTP由请求和响应构成，采用客户端-服务器模式工作。客户端也即浏览器或网络爬虫程序，发出HTTP请求，而服务器对请求进行响应。 具体的工作过程： 用户输入URL，客户端程序在完成域名解析后，获得服务器IP地址; 通过服务器上操作系统提供的TCP&#x2F;IP协议栈程序，与服务器建立TCP连接，与服务器建立TCP连接(TCP的三次握手); TCP连接建立后,客户端程序将HTTP请求封装为HTTP数据包，再封装为TCP数据包，发往服务器; 服务器接收HTTP请求后，根据请求内容进行响应,响应数据也封装为HTTP数据包，然后再封装为TCP包，回复给客户端。 服务器关闭这次TCP连接。等待新的请求。 三点注意事项： HTTP是无连接 无连接:限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。 HTTP是媒体独立的：客户端以及服务器指定使用适合的多用途互联网邮件扩展类型(MIME-type内容类型)。 HTTP是无状态 无状态是指协议对于事务处理没有记忆能力。 HTTP请求与响应HTTP请求方法HTTP1.0定义三种请求方法 GET方法：用于请求指定的页面信息,并返回实体主体。是最为常见的HTTP请求方法。 POST方法：向指定资源提交数据进行处理请求。数据被包含在请求体中。POST请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。 HEAD方法：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。 HTTP1.1新增五种请求方法 PUT方法：从客户端向服务器传送数据，取代指定文档的内容，类似于更新操作。 DELETE方法：用于请求服务器删除URL指定的资源。 OPTIONS方法：用于客户端查看服务器性能参数。 TRACE方法：用于回显服务器收到的请求，主要用于测试或诊断。 CONNECT方法：HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。 请求头部的参数内容 Accept参数：用于向服务器申明客户端(浏览器)可以接受的媒体类型(MIME)的资源 常见赋值：text&#x2F;html、application&#x2F;xhtm+xml、application&#x2F;xml类型表示客户端允许接收文本、HTML文件、XML文件等，可使用通配符*&#x2F;*。 Accept-encoding参数：参数的作用事项服务器声明客户端(浏览器)允许接收的压缩编码算法。 常见赋值：gzip,deflate或br等等。 Accept-Language参数：用于向服务器申明客户端允许接收的语言。 常见赋值：en-US, en和zh-CN等。 q，取值范围是从0到1，q表示了权重，en-US的权重最高，为1,中文网站通常会将zh的权重q设为0.9。 Cache-control参数：用于控制客户端的缓存。 常见赋值：private、no-cache、max-age、must-revalidate 默认为private，意思是由浏览器自身决定缓存大小。 Connection参数：用于设置浏览器是否需要与服务器持久连接。 常见取值：keep-alive和no; keep-alive表示需要持久连接,而no表示完成此次访问后即关闭连接。 Cookie参数：网站服务器为了辨别用户身份、进行会话跟踪而储存在用户本地终端上的数据(通常经过加密)。在HTTP请求头中设置这个参数，在向服务器发送请求时，就会将保存在该参数下的cookie值发送给web服务器，服务器根据这些值可以获得用户信息和访问历史。 Host参数：用于指定请求发往的服务器的域名和端口号。 Upgrade-insecure-Requests参数：被赋值为1时，用于声明浏览器支持从http请求自动升级为https请求，并且在以后发送请求的时候都使用https; 设置为0时则不允许升级为HTTPs。 User-Agent参数：用于向服务器发送浏览器的版本、系统、应用程序的信息。 常见赋值：Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64)、AppleWebKit&#x2F;537.36(KHTML, like Gecko)、Chrome&#x2F;72.0.3626.121、Safari&#x2F;537.36 Refer参数：用于告诉服务器，客户端是通过哪个页面跟踪到当前页面的。即客户端访问的上一页面地址。 HTTP响应HTTP响应结构 状态行 响应头部（消息报头） 空行 响应正文（消息体） HTTP响应状态码HTTP响应状态码也称为HTTP Status Code，它指示了当前网络访问的状态。HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。 HTTP状态码共分为5种类型： 从100到199：响应类型为“信息”，即服务器收到请求,提示客户端继续执行某项操作; 从200到299：响应类型为成功，表示客户端请求被服务器成功接收并处理; 从300到399：响应类型为重定向,表示客户端请求需要进一步的操作以完成请求; 从400到499：响应类型为客户端错误，表示请求包含语法错误或无法完成请求; 从500到599：响应类型为服务器错误，表示服务器在处理请求的过程中发生了错误。 一些常见的HTTP响应码: 状态码 含义 100 继续。客户端应继续其请求。 101 切换协议。服务器根据客户端的请求切换协议。 200 请求成功。一般用于GET与POST请求的响应。 201 已创建。请求成功并创建了新的资源。 202 已接受。即服务器已经接受请求，但未处理完成。 301 永久移动。请求的资源已被永久的移动到新URL，返回信息会包括新的URL，浏览器会自动定向到新URL。今后任何新的请求都应使用新的URL代替。 302 临时移动。与301类似。客户端应继续使用原有URL。 400 客户端请求的语法错误，服务器无法理解。 401 请求要求用户的身份认证。 403 服务器理解请求客户端的请求,但是拒绝执行此请求。 404 服务器无法根据客户端的请求找到资源(网页)。 500 服务器内部错误，无法完成请求。 501 服务器不支持请求的功能,无法完成请求。 502 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。 响应头部的参数内容 Access-Control-Allow-Origin参数：用于指定哪些网站可以跨域源资源共享。 常见取值：*，表示允许所有网站跨域共享。 Accept-Patch参数：用于指定服务器所支持的文档补丁格式。 例如取值：text&#x2F;example;charset&#x3D;utf-8表示支持文本，编码格式为utf-8。 Accept-Ranges参数：表示服务器所支持的内容范围。 常见取值为bytes。 Age参数：表示响应对象在代理缓存中存在的时间，以秒为单位。 Allow参数：用于指定对于特定资源的有效动作。常见取值：GET, HEAD等方法。 Cache-Control参数：用于通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒。 例设置值为max-age&#x3D;3600，表示缓存有效时间为1小时。 Content-Disposition参数：表示对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作。 Content-Encoding参数：表示响应资源所使用的编码类型。常见取值为gzip等。 Last-Modified参数：表示所请求的对象的最后修改日期。 Set-cookie参数：用于设置HTTP cookie值。 Date参数：用于指明响应发送时的日期和时间。 Expires参数：用于指定一个日期&#x2F;时间，超过该时间则认为此响应已经过期。 Server参数：用于指明服务器名称。 Transfer-Encoding参数：用于表示实体传输给用户的编码形式。 内容解析的对象HTML由**超文本标记语言(Hyper text markuplanguage，简称HTML)**组织的web网页是爬虫程序进行内容解析的主要对象。 HTML它是用来描述网页的一种语言。HTML不是一种编程语言,而是一种标记语言，HTML使用一套标记标签(markup tag)来描述网页中的组成内容。HTML标签标记的内容，连同标签本身，被称为HTML元素。 &lt;!DOCTYPE html&gt;声明为HTML5文档; &lt;html&gt;标签是HTML页面的根标签; 每一个HTML文档的最外层都是&lt;html&gt;标签对。 &lt;head&gt;标签用于定义HTML文档的头部，是所有头部元素的容器。HTML头部常含有&lt;title&gt;标签，用于定义文档的标题。 &lt;base&gt;标签，它为页面上的所有链接规定的默认地址或默认目标。&lt;link&gt;标签，用于定义文档与外部资源之间的关系。 &lt;link&gt;最常用于连接样式表。&lt;style&gt;标签用于为HTML文档定义样式信息。 &lt;meta&gt;标签 meta元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。&lt;body&gt;元素定义了可见的页面内容。&lt;h1&gt;-&lt;h6&gt;等标签用于定义HTML中从1级到6级的标题。这类标签标记的内容，会以粗体或大号字体形式显示。 &lt;p&gt;标签，用于定义HTML文档中的段落。&lt;a&gt;标签用于定义URL链接。URL链接通过标签中的属性给出。属性总以名称、值、对的形式出现，并总在HTML元素的开始标签中规定。每个html都可以设置属性，&lt;a&gt;标签中常见的属性是href。 &lt;img&gt;标签用来定义图像，标签img中，可以设置属性src，用于指定图片的路径位置; &lt;table&gt;标签用来定义表格。每个表格均有若干行，行由&lt;tr&gt;标签定义,，每行被分割为若干单元格，单元格由&lt;td&gt;标签定义。字母td指表格数据(table data)，即数据单元格的内容。数据单元格包含:文本、图片、列表、段落、表单、水平线、表格...无序列表由&lt;ul&gt;标签指定,有序列表由&lt;ol&gt;标签指定,列表中的每个列表项使用&lt;li&gt;来指定。 &lt;div&gt;标签是可用于组合其他 HTML元素的容器，本身没有特定的含义。常与CSS一同使用，对大的内容块设置样式属性。&lt;span&gt;标签可用作文本的容器，本身没有特定的含义。当与CSS一同使用时,&lt;span&gt;元素可用于为部分文本设置样式属性。 &lt;form&gt;标签用于定义HTML表单，表单用于搜集不同类型的用户输入。表单元素是指不同类型的input元素、复选框、单选按钮、提交按钮...&lt;script&gt;标签用于定义客户端脚本，比如JavaScript。script元素既可包含脚本语句，也可通过src属性指向外部脚本文件。JavaScript最常用于图片操作、表单验证以及内容动态更新。JAVASCRIPT脚本可以增强显示效果、加载数据。 HTML的样式包括外部样式表、内部样式表、内联样式。样式表，全称是层叠样式表(Cascading Stylesheets)，简称CSS。单独组织样式，是为了解决内容与表现分离的问题。HTML文档本身组织内容，CSS样式表定义如何显示。这样可以极大提高工作效率。HTML文档、CSS样式表、JavaScript脚本是网页中最常见的资源。 存储数据的仓库存储数据的方式： 以文本文件形式存储 以数据库形式存储 文本文件存储数据 格式 描述 纯文本文件 缺少格式控制，也被称为无结构文本，机器可读性较差 csv 全称是逗号分隔值文件，因为分隔字符通常是逗号。当分割符不是逗号时，可以称其为字符分隔值文件。 XML 被设计用来在互联网上传输和存储数据。 Json 是另一种文本文件。它使用JavaScript对象表示法来组织数据。 YAML 是另外一种文本文件。YAML是YAML Ain&#39;t a Markup Language的外文缩写。YAML的开发者认为YAML是一种对人类友好可读的，面向所有编程语言的数据序列化标准。 数据库管理系统关系型数据库关系型数据库是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。 关系型数据库支持事务的ACID原则。 ACID原则：Atomic原子性、Consistency一致性、Isolation隔离性、Durability持久性 关系型数据库具有容易理解、使用方便、易于维护的优点。但由于关系数据表存放在硬盘上，当访问量非常大时，磁盘I&#x2F;O是性能瓶颈，关系数据库的大表查询效率、多表关联查询，复杂SQL查询的效率较低，它的扩展性较差，不能简单通过添加更多的硬件和服务节点来扩展性能和负载能力。 非关系型数据库非关系型数据库指非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统。 易于扩展、适应大数据量查询，性能较高，具有灵活的数据模型，用户可以随时自定义数据格式，在不影响性能的情况下，可以方便地实现高可用架构。 没有标准，没有存储过程，不支持SQL语句，NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。 常见的NoSQL产品有三类: 类型 描述 典型代表 键值存储数据库 主要会使用到哈希表，在这个表中有一个特定的键和一个指针指向特定的数据。 TokyoCabinet&#x2F;Tyrant、Redis、Voldemort、OracleBDB 列存储数据库 这部分数据库通常是用来应对分布式存储的海量数据。 cassandra、HBASE、Rlak 文档型数据库 灵感来自于Lotus Notes办公软件，它同第一种键值存储相类似。 CouchDB、MongoDB、SequoiaDB 图形(Graph)数据库 图形结构的数据库同其它行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。 Neo4J、InfoGrid、InfiniteGraph"},{"title":"Hadoop | Hadoop初体验——实现两个excel表格的自然连接","path":"posts/5663f798/","text":"一次Hadoop Mapreduce作业的完成过程 应该是第一次正儿八经地接触与大数据相关的东西，好多名词都看不明白。 记录一下我完成这次作业时的思考。 先放代码 题目： 在关系代数中，自然连接(Natural join)是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。 根据给定的数据《student.xlsx》和《student_course.xlsx》，请使用MapReduce计算模型，实现表student和表student_course的自然连接，结果集包括学生学号、姓名、选修课程编号、考试成绩。 什么是Hadoop？Hadoop是一个能够对大量数据进行分布式处理的软件框架。 Hadoop框架透明地为应用提供可靠性和数据移动。它实现了名为MapReduce的编程范型：应用程序被分割成许多小部分，而每个部分都能在集群中的任意节点上执行或重新执行。此外，Hadoop还提供了分布式文件系统，用以存储所有计算节点的数据，这为整个集群带来了非常高的带宽。MapReduce和分布式文件系统的设计，使得整个框架能够自动处理节点故障。它使应用程序与成千上万的独立计算的电脑和PB级的数据连接起来。现在普遍认为整个Apache Hadoop“平台”包括Hadoop内核、MapReduce、Hadoop分布式文件系统（HDFS）以及一些相关项目，有Apache Hive和Apache HBase等等。 那分布式又是什么呢？（ 简单来说就是就是将一个需要巨大计算能力的问题分配给网络上多台计算机进行解决。 可能比较重要的HDFSHDFS，即Hadoop分布式文件系统，是一个使用Java语言进行编写的分布式的文件系统。一个HDFS集群一般由一个NameNode和若干DataNode组成。简单来说NameNode负责管理元信息（关于信息的信息），DataNode负责管理数据块。 MapReduce又是什么？MapReduce是由google提出的用于处理大规模数据集的计算模型，运行在HDFS之上。它包括JobTracker和TaskTracker两个主要组成部分，分别运行在NameNode和DataNode上。用户提交的数据处理请求称为Job，JobTracker将其分解成数据处理任务Task，分配给相关节点上的TaskTracker处理。 MapReduce模型简介 MapReduce将复杂的、运行于大规模集群上的并行计算过程高度地抽象到了两个函数： Map和Reduce 在MapReduce中，一个存储在分布式文件系统中的大规模数据集，会被切分成许多独立的 小数据块，这些小数据块可以被多个Map任务并行处理 MapReduce框架会为每个Map任务输入一个数据子集，Map任务生成的结果会继续作为 Reduce任务的输入，最终由Reduce任务输出最后结果，并写入到分布式文件系统中 MapReduce的工作过程 先从HDFS文件系统中读取数据 将读取的数据进行预处理后进行切分Split 通过RecordReader根据InputSplit中的信息处理其中的记录，加载数据并转换为合适Map任务读取的键值 Map阶段：将原始数据集解析成一批键值对 Shuffle： Shuffle横跨Map端和Reduce端，即Map shuffle和Reduce shuffle。在Map shuffle中对Map的结果进行分区、排序、合并。在Reduce shuffle中，Reduce领取数据放入缓存，归并合并后写入硬盘。 Reduce阶段：对每一批具有相同键的键值对进行输出 实例分析——实现关系的自然连接思路分析对于关系R(A,B)和S(B,C)，输出T(B,A,C) 在map过程中，将R中的每个元组转换成&lt;b,&lt;R,a&gt;&gt;，将S中的每个元组转换成&lt;b,&lt;R,c&gt;&gt;。所有具有相同B值的元组在同一个reduce进程中被合并，输出连接后的元组&lt;a,b,c&gt;。 实例给定了两个xlsx格式的表格，直接处理过于复杂。可以先借助POI等库或者手动转换文件格式至纯文本的csv(代码中包含对xlsx进行格式转换的类)。 在hadoop框架实现简单自然连接的操作很简单，只需要自定义mapper类和reducer类即可。 主类： 12345678910111213141516171819public class Driver &#123; public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException &#123; Configuration conf = new Configuration();//加载配置文件,如有改动则覆盖默认配置 Job job = Job.getInstance(conf);//根据配置信息实例化job对象 job.setJarByClass(Driver.class); //设置job的主入口程序 //设置mapper类 job.setMapperClass(MyMapper.class); //设置reducer类 job.setReducerClass(MyReducer.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(Text.class); FileInputFormat.setInputPaths(job, new Path(&quot;/home/hadoop/Documents/data&quot;)); FileOutputFormat.setOutputPath(job, new Path(&quot;/home/hadoop/Documents/dataOutput&quot;)); boolean result = job.waitForCompletion(true); System.exit(result ? 0 : 1); &#125;&#125; mapper类： 12345678910111213141516171819202122232425262728293031public class MyMapper extends Mapper&lt;LongWritable, Text, Text, Text&gt; &#123;//这里定义了一个mapper类，其中有一个map方法。MapReduce框架每读到一行数据，就会调用一次这个map方法。 @Override protected void map(LongWritable key,Text value,Mapper&lt;LongWritable, Text, Text, Text&gt;.Context context) throws IOException,InterruptedException&#123; /* 其中key是传入map的键值，value是对应键值的value值，context是环境对象变量，供程序访问Hadoop的环境参数 map方法对输入的键值对进行处理，产生一系列的中间键值对，转换后的中间键值对可以有新的键值类型。 输入的键值对可根据实际应用设定，例如文档数据记录可将文本文件中的行或数据表格中的行设为key，对应行的类容为value */ Text outKey = new Text(); Text outValue = new Text(); FileSplit fileSplit = (FileSplit) context.getInputSplit(); String filePath = fileSplit.getPath().toString(); String line = value.toString(); //输出键值对中的值加入&quot;student&quot;/&quot;student_course&quot;字段的目的是能够在reduce阶段对键值对的来源进行判断从而进行不同的处理 //切割表格时的切割份数与输出时选用的部分对应题目要求 if (filePath.contains(&quot;student.csv&quot;))&#123; String[] allS = line.split(&quot;,&quot;,3); outKey.set(allS[0]); outValue.set(&quot;student&quot;+&quot; &quot;+allS[1]); &#125; else if (filePath.contains(&quot;student_course.csv&quot;))&#123; String[] allC = line.split(&quot;,&quot;,4); outKey.set(allC[0]); outValue.set(&quot;student_course&quot; + &quot; &quot; + allC[1]+&quot;,&quot;+allC[2]); &#125; context.write(outKey,outValue); &#125;&#125; 需要注意，在Hadoop中并没有使用java的基本类型类，而是使用自己开发的类。详细内容可以查看这篇博文hadoop中典型Writable类详解。 reducer类： 123456789101112131415161718192021222324public class MyReducer extends Reducer&lt;Text, Text, Text, Text&gt; &#123; private ArrayList&lt;String&gt; record = new ArrayList&lt;&gt;(); private final Text value = new Text(); private String name; @Override protected void reduce(Text key,Iterable&lt;Text&gt; values,Reducer&lt;Text,Text,Text,Text&gt;.Context context) throws IOException, InterruptedException &#123; record = new ArrayList&lt;&gt;(); for (Text val : values)&#123; String[] fields = StringUtils.split(val.toString(),&#x27; &#x27;); String flag = fields[0]; //判断键值对来自哪一个表格，进行相应处理 if (flag.equals(&quot;student&quot;))&#123; name = fields[1]; &#125; else if (flag.equals(&quot;student_course&quot;))&#123; record.add(fields[1]); &#125; &#125; for (String i:record)&#123; value.set(name+&quot;,&quot;+i); context.write(key,value); &#125; &#125;&#125;"},{"title":"Hexo | 记录一下建立这个博客的过程","path":"posts/ae4e4f24/","text":"历时13天，本博客终于基本施工完成了。博客的第一篇文就简单记录一下对前端零了解的我瞎折腾的过程。 基础功能说说&#x2F;artitalk.js起初看到一个typecho博主实现了这个功能，不过似乎是通过微信公众号发布说说，然后将内容嵌入的博客中。稍微搜索了一下没有找到相关的教程，而且好像整微信公众号什么的似乎也很麻烦，就放弃了这个想法。 经过一小段时间的搜索，我发现Artitalk.js就很符合我的需求。 Artitalk.js是基于 LeanCloud 实现的可实时发布说说&#x2F;微语的 js 增删查改全方面支持 支持针对每条说说的评论 支持 Markdown&#x2F;html 语法 支持图片上传 使用也很简单，注册一个LeanCloud国际版账号，按照使用说明的教程进行配置。然后新建一个post，直接在其中添加 12345678&lt;script type=&quot;text/javascript&quot; src=&quot;https://unpkg.com/artitalk&quot;&gt;&lt;/script&gt;&lt;div id=&quot;artitalk_main&quot;&gt;&lt;/div&gt;&lt;script&gt;new Artitalk(&#123; appId: &#x27;&#x27;, // Your LeanCloud appId appKey: &#x27;&#x27; // Your LeanCloud appKey&#125;)&lt;/script&gt; 发布界面后就可以看到配置成功的提示了。 一个小问题：加载动画与说说容器上方的内容有重叠后面将content容器的背景改为半透明时，发现加载动画背景有白块，很丑，于是干脆把加载动画关掉了 不怎么会用typora，本想着用空格什么的占位符让加载动画和上方的分割线空出些距离，但这样会产生一部分能选中的文本，本强迫症无法接受，于是怒打开ps，做了一个细长的全透明图片，插在分割线和说说容器之间。 虽然稍微有些蠢，但不也挺好的吗（ 加载动画：没注意大小啊在把content容器的背景改为半透明之后，输入框里的新科娘的白色背景十分刺眼。找了张ほし老师的Q版画，抠图，传图床，看实际效果的时候发现图好大（ 于是去github删掉图片，ps里调整大小和位置，又重新上传了一下，但是cdn的刷新有延迟，搜了一下刷新Jsdelivr缓存的方法，发现竟然还真有！ 把Jsdelivr链接中的cdn替换成purge 但即便刷新之后还是有大概10min的延迟，我就进行了3次处理上传-&gt;等待刷新-&gt;查看效果发现大小不行-&gt;处理上传的循环（ 反应过来以后我觉得我就是个啥宝，f12找出加载图的资源地址，直接查看这张图的大小不就行了吗（ 评论功能&#x2F;valine-&gt;disqus-&gt;disqusjs一开始使用valine一是因为感觉用valine的真的很多，而且用起来很方便，只需要在LeanCloud中再建一个应用给评论就行。但是看valine的帮助文档的时候，发现真的有好多问题，不兼容pjax、自带的邮件提醒下线、第三方的邮件提醒的配置我看不懂（…… 后来看到别人博客的disqus，感觉不错于是我也换了disqus，注册了一个账号，修改了一下主题配置，感觉良好，还支持邮件提醒。但是！当我不科学上网时，发现评论区根本加载不出来（，这时候才发现原来disqus被墙了。 接着改用disqusjs，惊喜地发现在使用文档里有这么一句： DisqusJS v1.2.6 开始支持检测是否存在 Disqus 实例，并在加载 Disqus 时直接调用 DISQUS.reset() 方法重载 Disqus 评论，无需用户手动销毁现有的 Disqus 实例。 虽然不是很明白，但感觉应该就是不用根据pjax调整了吧（ 听说disqus是有广告的，但这都1202了，不会还有人没有adblock吧（ 后来在禁用插件的情况下访问发现广告实在太碍眼，便搜索去除disqus广告的方法。 在style.css中添加 123iframe:not([src]) &#123; display: none; &#125; 即可。 美化与优化live2d看板娘起初参考的这篇文章:Hexo 博客优化之博客美化系列（持续更新） 虽然使用很简单但仅有一个冻鳗人物实在是没什么意思，翻了一会翻到了就发现了这个，支持换人换装和对话框。使用文档说的很多，我也看不太懂。就在layout中加了一句 1&lt;script src=&quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js&quot;&gt;&lt;/script&gt; 生成网页后有效果了，我就暂时搁置了。 但在整完pjax后，我发现我可以大致看懂使用文档了。 initWidget 方法接受名为 apiPath 和 cdnPath 的参数，两者设置其中一项即可。其中 apiPath 为后端 API 的 URL，可以自行搭建，并增加模型。 我找到了默认的后端api仓库，然后查看其fork列表，发现这个仓库被第二次fork的次数最多，于是我也fork了一下这个仓库，改了一点参数并删除了我不想要的模型，达成想要实现的效果了！ 音乐播放器耗时最长的东西其一。 初次接触时看着什么APlayer,Meting,hexo-tag-aplayer一头雾水，理不清谁是谁，有什么区别。甚至看不出他们的使用方法里写的是什么语言（ 所幸搜到了这篇博文，这我不就明白了吗（， 123456&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;my-aplayer&quot; class=&quot;aplayer&quot; &gt;&lt;/div&gt; 为其他配置项赋好值以后，把这段html代码加到页面中，成功得到一个在右侧顶端的音乐播放器。至少我用的nexmoe主题是这样 播放列表无法展开！怎么点播放列表也没反应啊，没有办法。我的第一个想法是通过自定义修改css和js文件把列表那个按钮给去掉！但是我当时还不知道怎么处理不在本地的css后来才知道可以下载后放在source文件夹中在把href值改成绝对路径，而且这个css的排版也乱的不行毫无可读性可以在页面f12找到对应按钮的css标签然后在本地搜索（。 于是我开始猜想打不开列表的原因。首先我想到我并没有调整css给播放器在页面上安排一个位置大概，但是播放器确如我所愿在content容器之上，那有没有一种可能是容器的大小被设定成了播放器的大小，列表展开后处在容器之外呢？ 打开f12，确实验证了我这个想法。 上网搜索css如何自适应高度，得到的方法是在style中设置display值为&#39;table&#39;，完美解决。 切换界面音乐就停了一开始让我用pjax我是拒绝的，因为其使用文档我一丁点也看不明白（ 在使用pjax之前，没刷新一次界面，看板娘也会跟着刷新一遍，我不以为意。但在整好音乐播放器以后这个问题就没法忽视了，这一切换页面音乐就停了也太蠢了。 于是被迫看懂看不懂的东西，耗时最长的东西其二就来了。 pjax pjax是基于ajax+pushState的新技术，该技术可以无刷新改变页面的内容，并且可以改变页面的URL。 初次尝试pjax时，按照其他博主的教程用npm安装，引入js，照猫画虎地写了一段（应该是php?）代码。但测试发现并没有任何效果。 1$(document).pjax(&#x27;a&#x27;, &#x27;#pjax-container&#x27;) 经过不懈的瞎努力尝试，终于明白这个容器参数前的&#39;#&#39;或&#39;.&#39;是有具体含义的。仔细阅读pjax的Usage后，了解到这就是css selector。 .x就是选择class值为x的元素 #y就是选择所有id值为y的元素 更改代码后终于成功实现了无刷新改变界面，但是此时出现了一个新问题。 pjax只支持刷新一个容器？？点击左侧的按钮，右侧的内容容器确实在无刷新改变。但是左侧的按钮，它状态不变了！！翻遍pjax的说明文档似乎并没有说如何刷新两个容器，百度无果，谷歌用英语终于搜到了答案：pjax不支持刷新两个容器！ 无奈，新建了一个标签将左侧和右侧，也就是header与content全部包裹在一起，这样的话每次启用pjax都会刷新按钮状态了。 jQuery过时了？在很多博主的文章里都能看到他们因为jQuery的原因舍弃了pjax，不过我在某一篇文章的评论区中看到有人说有大佬做出了不需要jQuery的pjax？ 正好当时在用的jQuery-pjax不知道为何一添加NProgress之类的就会彻底失效。抱着试试看的态度我删除了原来的pjax使用了MoOx&#x2F;pjax。结果真的是超乎我的意料，不仅切换界面的流畅度大大提升，能够使用NProgress，支持多容器刷新，并且原来在一个界面停留时间过长pjax会失效的bug，以及窗口大小低时header部分会抽风的bug也解决了。唯一无伤大雅的缺点是网址上会多一个时间戳（ 还有一个bug（看到左侧的搜索栏了吗，这个搜索会重新刷新整个界面，暂时我还没找到解决方法捏（ 要不干脆改成站外搜索吧（ 动画特效&#x2F;animate.css起初我看到一个搜图网站的加载动画做得非常好看，于是我就想偷借过来用一下（ f12打开控制台，只看见无数的js，我全部复制下来引用到自己的layout文件中，copy了看起来相关的css和html代码。最后发现这个加载动画，它停不下来啊！ 折腾了半天无果现在已经实现了阉割版，在我删掉引入的乱七八糟的js时我看见了这样一个名字的css：animate.min.css。 了解后发现网页的很多简单特效都可以用这个轻易完成。这里有动画效果演示。引入css后只需要在想要添加动画效果的容器的class中加上实例中的动画名称就可以了。 其他解决了一个又一个问题，我初步对css、js和html有了一丁点了解。在能够熟练地瞎改css后，我也成功将界面改成圆角并做成了蓝色半透明的感觉！ 本文完成时博客的界面： 在实现我的预期功能时，因个人能力原因妥协了很多，最终成品也是有很多不足，但我也十分满意了，在胡乱折腾的过程中也十分开心，希望以后我可以做得更好吧。"}]